<script>
  // -------- Local cache helpers --------
  const CACHE_KEY = 'avb_cache_v1'; // { banks, aaveTVL, updatedAt }
  function readCache(){
    try { return JSON.parse(localStorage.getItem(CACHE_KEY) || 'null'); }
    catch { return null; }
  }
  function writeCache(data){
    try { localStorage.setItem(CACHE_KEY, JSON.stringify(data)); } catch {}
  }
  function clearCache(){ try { localStorage.removeItem(CACHE_KEY); } catch {} }

  // -------- Fallback bank data (unchanged) --------
  const bankData = [ /* ... your long fallback array stays the same ... */ ];

  function formatAssets(amount) {
    return `$${amount.toFixed(1)} B`;
  }

  function generateRankChange() {
    const up = Math.random() > 0.5;
    const places = Math.floor(Math.random() * 4) + 1; // 1–4 places
    return { direction: up ? 'up' : 'down', places, symbol: up ? '▲' : '▼' };
  }

  async function fetchAaveTVL() {
    try {
      const res = await fetch('https://api.llama.fi/protocol/aave', { cache: 'no-store' });
      if (!res.ok) throw new Error('Bad response');
      const data = await res.json();
      const last = data?.tvl?.[data.tvl.length - 1] || {};
      const tvl = last.totalLiquidityUSD ?? last.totalLiquidityUsd ?? last.totalLiquidity;
      if (typeof tvl === 'number') return tvl / 1_000_000_000;
    } catch (e) { console.error('Aave TVL fetch failed', e); }
    return null;
  }

  async function fetchBankData() {
    try {
      // HTML scrape via CORS proxy is slow; only used on manual refresh now.
      const proxyUrl = 'https://api.allorigins.win/get?url=';
      const targetUrl = encodeURIComponent('https://www.federalreserve.gov/releases/lbr/current/');
      const response = await fetch(proxyUrl + targetUrl, { cache: 'no-store' });
      if (!response.ok) throw new Error('Failed to fetch bank data');

      const { contents } = await response.json();
      const doc = new DOMParser().parseFromString(contents, 'text/html');
      const rows = doc.querySelectorAll('tr');
      const extracted = [];

      for (const row of rows) {
        const tds = row.querySelectorAll('td');
        if (tds.length >= 6) {
          const name = tds[0]?.textContent?.trim() || '';
          const assetsStr = tds[5]?.textContent?.trim() || '';
          if ((name.includes('BK') || name.includes('BANK')) && assetsStr) {
            const n = parseFloat(assetsStr.replace(/[^0-9.]/g, ''));
            if (!isNaN(n) && n > 100) extracted.push({ name: name.split('/')[0].trim(), assets: n / 1000 });
          }
        }
      }
      return extracted.sort((a,b)=>b.assets-a.assets).slice(0,50);
    } catch (e) {
      console.error('Bank fetch failed', e);
      return bankData;
    }
  }

  function renderTable(allBanks, aaveTVL) {
    const tableBody = document.getElementById('tableBody');
    tableBody.innerHTML = '';

    const combined = [...allBanks, { name: 'Aave', assets: aaveTVL ?? 12.5, isAave: true }];
    const sorted = combined.sort((a,b)=>b.assets-a.assets);
    const aaveIndex = sorted.findIndex(i => i.isAave);

    const start = Math.max(0, aaveIndex - 4);
    const end = Math.min(sorted.length - 1, aaveIndex + 5);
    const slice = sorted.slice(start, end + 1);

    slice.forEach((item, i) => {
      const rank = start + i + 1;
      const ch = generateRankChange();
      const isAave = !!item.isAave;

      const tr = document.createElement('tr');
      if (isAave) tr.className = 'aave-row highlight';

      const nameCell = isAave
        ? `<span class="logo" aria-hidden="true">
             <img src="aave.svg" alt="Aave logo" style="width:150px; height:72px; vertical-align:middle;">
           </span>`
        : item.name;

      tr.innerHTML = `
        <td data-label="Rank">${rank}
          <span class="rank-change ${ch.direction}" aria-label="rank change ${ch.direction} by ${ch.places}">
            ${ch.symbol} ${ch.places}
          </span>
        </td>
        <td data-label="Name">${nameCell}</td>
        <td data-label="Assets">${formatAssets(item.assets)}</td>
      `;
      tableBody.appendChild(tr);
    });

    const info = document.getElementById('error');
    info.textContent = `Showing Aave (rank ${aaveIndex + 1}) with 4 banks above and 5 banks below. Total institutions: ${sorted.length}`;
    info.style.display = 'block';
    info.style.color = '#ffffff';
    info.style.opacity = '0.8';
  }

  function setUIState({ loading }) {
    document.getElementById('loading').style.display = loading ? 'block' : 'none';
    document.getElementById('dataTable').style.display = loading ? 'none' : 'table';
    if (loading) document.getElementById('error').style.display = 'none';
  }

  function setLastUpdated(ts, label='') {
    const el = document.getElementById('lastUpdated');
    const when = ts ? new Date(ts).toLocaleString() : new Date().toLocaleString();
    el.textContent = `Last updated: ${when}${label ? ' ' + label : ''}`;
  }

  // ---- Fast path on open: render from cache if available; no network ----
  async function loadFromCacheOrFetchOnce() {
    const cached = readCache();
    if (cached?.banks?.length) {
      // Instant render
      renderTable(cached.banks, cached.aaveTVL ?? 12.5);
      setUIState({ loading: false });
      setLastUpdated(cached.updatedAt, '(cached)');
      return;
    }
    // No cache yet: do a single fetch
    await doNetworkRefresh({ showHint: false });
  }

  async function doNetworkRefresh({ showHint = true } = {}) {
    setUIState({ loading: true });
    try {
      const [banks, aaveTVL] = await Promise.all([fetchBankData(), fetchAaveTVL()]);
      const allBanks = banks.length > 20 ? banks : bankData;
      renderTable(allBanks, aaveTVL ?? 12.5);
      setUIState({ loading: false });
      const nowISO = new Date().toISOString();
      setLastUpdated(nowISO);
      writeCache({ banks: allBanks, aaveTVL: aaveTVL ?? 12.5, updatedAt: nowISO });
    } catch (e) {
      console.error('Refresh failed', e);
      renderTable(bankData, 12.5);
      setUIState({ loading: false });
      setLastUpdated(null, '(Fallback Data)');
    }

    // optional UX hint after manual refresh
    if (showHint) {
      const hint = document.getElementById('refreshHint');
      setTimeout(() => { hint.textContent = 'You might need to refresh.'; }, 2500);
    }
  }

  function setupRefresh() {
    const btn = document.getElementById('refreshBtn');
    const hint = document.getElementById('refreshHint');

    btn.addEventListener('click', async () => {
      hint.textContent = '';
      btn.disabled = true;
      const original = btn.textContent;
      btn.textContent = 'Refreshing…';
      await doNetworkRefresh({ showHint: true });
      btn.textContent = original;
      btn.disabled = false;
    });
  }

  document.addEventListener('DOMContentLoaded', async () => {
    setupRefresh();
    // Instant: use cached data if present; otherwise one fetch.
    await loadFromCacheOrFetchOnce();
  });

  // ❌ No auto/timed refreshes anywhere.
</script>
